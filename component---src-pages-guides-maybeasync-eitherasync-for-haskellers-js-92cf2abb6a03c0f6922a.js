"use strict";(self.webpackChunkpurify_website=self.webpackChunkpurify_website||[]).push([[935],{7957:function(e,t,n){n.r(t);var a=n(7294),r=n(292),s=n(6774),i=n(9731),l=n(3904),o=n(5078);t.default=function(e){return a.createElement(r.Z,{location:e.location},a.createElement("h1",null,"MaybeAsync and EitherAsync for Haskellers"),a.createElement(o.Note,null,"Keep in mind a lot of stuff have changed since this was written (back in January 2019), Either and MaybeAsync evolved to be more distant than the monad transformer design in late 2020",a.createElement("br",null)," and instead adopted the PromiseLike interface to make it easier to work with and reduce the large amount of boilerplate the original implementation required."),a.createElement("br",null),"As mentioned in the description of those data types, MaybeAsync and EitherAsync are funky Promise-specialized monad transformers for Maybe and Either.",a.createElement("br",null),"Some things may feel out of place and that is completely intentional, porting monad transformers over to TypeScript was just not practical, especially the higher-kinded types and typeclasses part.",a.createElement("br",null),"A lot of thought went into designing the APIs and I believe that the result is satisfactory. In fact, even though the implementation is completely different, code written in mtl style looks pretty similar! Here, take a look:",a.createElement(i.Z,{language:"haskell",style:l.Z},"tryToInsertUser user = runExceptT $ do\n  validatedUser <- liftEither $ validateUser user\n  userExists <- lift $ doesUserAlreadyExist validatedUser\n\n  when userExists (throwE UserAlreadyExists)\n\n  maybeToExceptT ServerError $ do\n    updatedUser <- MaybeT $ hashPasswordInUser user\n    lift $ insertUser updatedUser"),"Keep in mind this code is not representative of the perfect or cleanest implementation for such a feature, I tried to shove as much functions, that are also possible in Maybe-EitherAsync, as I could.",a.createElement("br",null),"Here's the same logic implemented with purify in TypeScript:",a.createElement(i.Z,{language:"typescript",style:l.Z},"const tryToInsertUser = user =>\n  EitherAsync(async ({ liftEither, throwE, fromPromise }) => {\n    const validatedUser = await liftEither(validateUser(user))\n    const userExists = await doesUserAlreadyExist(validatedUser)\n\n    if (userExists) throwE('UserAlreadyExists')\n\n    return fromPromise(MaybeAsync(async ({ fromPromise }) => {\n        const updatedUser = await fromPromise(hashPasswordInUser(user))\n        return insertUser(updatedUser)\n    }).toEitherAsync('ServerError').run())\n  })"),"One important thing to understand about Maybe and EitherAsync is that the docs and the API create the illusion that code is running in some custom magical context that lets you safely unwrap values.",a.createElement("br",null),'Is it referred to as "MaybeAsync context" or "EitherAsync context", but in fact there\'s no magic and the only real context is the async/await block.',a.createElement("br",null),'That allows us to simulate do-notation using await and what those "lifting" function actually do is return Promises that get rejected when a value is missing. ',a.createElement("br",null),"The `run` function will later on catch all those rejections and return a proper Maybe/Either value.",a.createElement("h3",null,"Glossary of functions"),a.createElement("ul",null,a.createElement("li",null,"MaybeAsync<a>"," = MaybeT IO a"),a.createElement("li",null,"EitherAsync<e, a>"," = ExceptT e IO a"),a.createElement("li",null,"liftEither/Maybe = liftEither/Maybe (",a.createElement(s.HL,null,"MaybeT/ExceptT . return")," in Haskell, but nothing like that in purify, they function the same though)"),a.createElement("li",null,"fromPromise = the MaybeT/ExceptT constructor (you only need to wrap the IO action with the newtype in Haskell, in purify it's not as simple)"),a.createElement("li",null,"throwE = throwE"),a.createElement("li",null,"MaybeAsync#toEitherAsync = maybeToExceptT (from the"," ",a.createElement("a",{href:"http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html#v:maybeToExceptT"},"transformers package"),")"),a.createElement("li",null,"EitherAsync#toMaybeAsync = exceptToMaybeT")))}}}]);
//# sourceMappingURL=component---src-pages-guides-maybeasync-eitherasync-for-haskellers-js-92cf2abb6a03c0f6922a.js.map