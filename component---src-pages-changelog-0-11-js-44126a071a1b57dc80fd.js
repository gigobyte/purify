"use strict";(self.webpackChunkpurify_website=self.webpackChunkpurify_website||[]).push([[970],{7589:function(e,t,n){n.r(t);var a=n(7294),l=n(3917),r=n(4219),i=n(9731),o=n(3904),s=n(292),u=n(6774),c=l.default.h1.withConfig({displayName:"sc-011__Title",componentId:"sc-1dowjy1-0"})(["margin-bottom:0;"]),m=l.default.div.withConfig({displayName:"sc-011__Subtitle",componentId:"sc-1dowjy1-1"})(["padding-bottom:30px;"]),p=l.default.h2.withConfig({displayName:"sc-011__Topic",componentId:"sc-1dowjy1-2"})(["font-weight:normal;"]),d=l.default.div.withConfig({displayName:"sc-011__TopicDescription",componentId:"sc-1dowjy1-3"})(["padding-right:15%;@media only screen and (max-width:768px){padding-right:0;}"]);t.default=function(e){return a.createElement(s.Z,{location:e.location},a.createElement(c,null,"Purify v0.11"),a.createElement(m,null,"September 20, 2018"),a.createElement("div",null,"Not sure what purify is? Check out the"," ",a.createElement(r.ZP,{to:"/getting-started"},"Getting Started")," page. The package was renamed from `pure-ts` because of NSFW search results."),a.createElement(p,null,"NonEmptyList"),a.createElement(d,null,"The new NonEmptyList ADT is a list that is guaranteed to have at least one value. Because of it's utility there is an implementation of this data structure in pretty much all ML languages, which is why it's now a part of purify too. Let's look at some example code:",a.createElement(i.Z,{language:"javascript",style:o.Z},"import { NonEmptyList, head } from 'purify-ts/adts/NonEmptyList'\n\n// Create functions with a contract - the caller has to verify that the input is valid instead of the callee\n// Since the list parameter is guaranteed to have at least one element, this function will always return a value\nconst getRandomElement = <T>(list: NonEmptyList<T>): T =>\n    list[Math.floor(Math.random() * list.length)]\n\n// Doesn't compile\ngetRandomElement(NonEmptyList([]))\n\n// Compiles, you don't need to check for elements if the list length is known at compile time\ngetRandomElement(NonEmptyList([1]))\n\n// For runtime values, you have to deal with a Maybe\nconst numbers: number[] = getArrayFromForm()\nconst randEl: Maybe<number> = NonEmptyList.fromArray(numbers).map(getRandomElement)\n                ")),a.createElement(p,null,"Maybe and Either predicates narrow the type"),a.createElement(d,null,"v0.11 makes a lot of improvements to type safety. Using one of TypeScript's more unique features - type predicates, the compiler can now know when it's safe to extract a value from a Maybe or Either.",a.createElement(i.Z,{language:"javascript",style:o.Z},"const sometimesValue: Maybe<number> = ...\n\nsometimesValue.extract() // number | null\n\nif (sometimesValue.isJust()) {\n    // Because extract() is in a block that guarantees the presence of a value, it's safe to return a number instead of a nullable number\n    sometimesValue.extract() // number\n}\n                ")),a.createElement(p,null,"Wildcard pattern for pattern matching"),a.createElement(d,null,"You can now use a wildcard when pattern matching a Maybe, Either or any other ADT that supports pattern matching.",a.createElement(i.Z,{language:"javascript",style:o.Z}," // v0.10\nadt.caseOf({ Just: value => 0, Nothing: () => 0})\n\n// Now\nadt.caseOf({ _: () => 0 })")),a.createElement(p,null,"Tuple support for more array behaviour"),a.createElement(d,null,"Tuples now implement the Iterable and ArrayLike interfaces."),a.createElement(i.Z,{language:"javascript",style:o.Z}," const [ fst, snd ] = Tuple(1, 2)"),a.createElement(p,null,"New Maybe and Either methods"),a.createElement(d,null,"Check out the docs for Maybe and Either to find out more about the following methods:",a.createElement("ul",null,a.createElement("li",null,a.createElement(u.HL,null,"Maybe.fromPredicate"),", ",a.createElement(u.HL,null,"Maybe#join")," and"," ",a.createElement(u.HL,null,"Maybe#orDefaultLazy")),a.createElement("li",null,a.createElement(u.HL,null,"Either#join")," and ",a.createElement(u.HL,null,"Either#orDefaultLazy")))),a.createElement(p,null,"Improved pretty printing"),a.createElement(d,null,"When using ",a.createElement(u.HL,null,"toString")," on ADT instances now it displays the constructor name. Keep in mind that this behaviour is strictly for pretty printing, in the case of ",a.createElement(u.HL,null,"JSON.stringify")," it strips out any ADT info and leaves only relevant JSON data.",a.createElement(i.Z,{language:"javascript",style:o.Z},'const val = Just(5)\nconsole.log(val.toString()) // "Just(5)"\nconsole.log(JSON.stringify(val)) // "5"')),a.createElement(p,null,"All functions with multiple arguments support partial application"),a.createElement(d,null,a.createElement("div",null,"Added partial application support to: ",a.createElement(u.HL,null,"List#at")),a.createElement("div",null,"Improved partial application for: ",a.createElement(u.HL,null,"Tuple.fanout"),","," ",a.createElement(u.HL,null,"Maybe.mapMaybe"))),a.createElement(p,null,"Other changes"),a.createElement(d,null,a.createElement("ul",null,a.createElement("li",null,"Removed ",a.createElement(u.HL,null,"Semigroup")," and ",a.createElement(u.HL,null,"Ord")," instances because they were not sound and making them typesafe required using very confusing type definitions."),a.createElement("li",null,"Fixed ",a.createElement(u.HL,null,"Either#isRight")," type definition (thanks"," ",a.createElement("a",{href:"https://github.com/sledorze"},"sledorze"),")"),a.createElement("li",null,"Made the ",a.createElement(u.HL,null,"value")," property inside the Maybe class private"),a.createElement("li",null,"Reduced package size by excluding the tests"),a.createElement("li",null,"Many improvements (rewordings, corrections and clarifications) made to the docs (thanks ",a.createElement("a",{href:"https://github.com/squirly"},"squirly"),")"))))}}}]);
//# sourceMappingURL=component---src-pages-changelog-0-11-js-44126a071a1b57dc80fd.js.map